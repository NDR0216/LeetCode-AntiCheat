# LeetCode AntiCheat

## File Structure
* `01_get_code.ipynb`: the script to download the submission code, and generate `CONTEST_NAME.csv`
* `02_group_cheater.ipynb`: the script to merge cheaters into the mass cheating group
* `03_update_rank.ipynb`: the script to check whether the cheater gets disqualified
* `CONTEST_NAME`: each contest has their own folder
  * `CONTEST_NAME.csv`: a csv to record the user name and their submission ID.
  * `Q3.csv`: record the rank, user name, and submission ID of the mass cheating group. Will be generated by `02_group_cheater.ipynb`
  * `Q4.csv`
  * `Q3`: the folder of submission code
    * `0001-1000`
      * `1.cpp`: the code of ranking 1
    * ...
  * `Q4` 
* `markdown.txt`: markdown for post purpose 


## 1. 01_get_code
> Download the submission code, and generate `CONTEST_NAME.csv`
* It's pretty SLOW because of the rate limit of Cloudflare
* Usually I only check the person who solved at least 3 questions

## 2. run the detection tool
* the most popular is [MOSS by Stanford](https://theory.stanford.edu/~aiken/moss/), but the tool is run on a server, and the submission limit is 100 submissions/day/user
* Maybe there is a MOSS clone? but I haven't found it yet.
* As a result, I use https://github.com/blingenf/copydetect to run locally.
* I chose this tool because I can check the similarity between two codes visually, but the cons are dealing with HTML output can be very slow or even impossible if the input size is very large
* `-t` and `-e` is the folder and the file extension gonna be detected,  `-d` is the threshold, and `-O` is the file name of the output HTML
```bash
copydetect -t Q3 -e cpp -d 0.95 -O Q3_cpp.html
copydetect -t Q3 -e py -d 0.95 -O Q3_py.html
copydetect -t Q3 -e java -d 0.95 -O Q3_java.html
copydetect -t Q4 -e cpp -d 0.95 -O Q4_cpp.html
copydetect -t Q4 -e py -d 0.95 -O Q4_py.html
copydetect -t Q4 -e java -d 0.95 -O Q4_java.html
```
* Here is the example output. The output will only show the comparison where the percentage of the test file is larger than the threshold.
* It means that 95% of the test file appears in the reference, and 50% of the reference file appears in the test file
```
Test file: test\1.py (96.00%)
Reference file: test\1373.py (50.00%)
```
* I set the threshold to 0.95 because even 0.95 can produce an enormous amount...... The default is 0.33 FYI. Basically, anything above 0.33 **MIGHT** be plagiarism.
* And I only check C++, Python, and Java at most because almost nobody uses other languages, and it's super easy to get caught :)

## 3. 02_group_cheater
> Merge cheaters into the mass cheating group
* Union Find algorithm !!!
* Usually I only report large mass group cheating. For small numbers, I just let it be :)
---
* Q: How to prevent false positives?
* A: There would be a lot of false positives. Right now, I merge them only if Both A and B are 95% (aka set `THRESHOLD` to 95) similar to each other, and manually check the rest.
* If a top-rank user writes very concise code, it might be 95% similar to the cheater's just like the sample output I provided. As a result, we have to manually check.
* 95% is pretty safe unless the question is too easy, but there will be a lot of cases that need to be manually checked.
* Maybe could reduce the percentage to 90% to automate more stuff? Or even lower?

* Q: What if the output HTML is too large
* A: set the `THRESHOLD` to 100, run the `clear 100%` code block, and rerun the detection tool
  * the output size of the detection tool is O(N<sup>2</sup>), which means if there are 1,000 cheaters, the output size will be 1,000,000......
  * In order to reduce the size of HTML, I usually will delete the files which match 100%, and only keep one copy

## 4. 03_update_rank
> Check whether the cheater gets disqualified
* Not necessary. Only for post-update purposes.
